## 動機

## 制作物
スマートフォン本体の動きを元に音が出る楽器アプリケーションを制作している。自分の持っている技術の傾向から、これをWebサイトとして開発している。

## Webの利点
Webサイトとして開発することで、スマートフォンのOSの違いによる影響を抑えることやWebサイトにアクセスするだけで体験することができることなどのアドバンテージを得ることができる。

## Webの制約
上記のアドバンテージを得られる一方、Webブラウザ上で動くJavaScript(以後、JavaScript)でできることには制約が多く、何度か根本的なアプローチの変更を余儀なくされた。
一番大きな制約は、モーションセンサーの制約である。スマートフォンの動きをアプリケーション上から取得するためには、スマートフォンに埋め込まれているセンサーの値を取得する必要がある。JavaScriptにはそのためのAPIが用意されており、今回は加速度・角速度・デバイスの向きの3つの値を取得・処理している。
通常、ネイティブアプリケーションではこれらの値の1秒あたりのサンプリング数を必要に応じて指定することができるが、JavaScriptに用意されているAPIではその指定をすることができず、固定されている。
シングルスレッドというJavaScriptの特性上、サンプリング数を上げすぎるとセンサーからの値を処理する際に他の必要な処理を邪魔してしまったり、逆に邪魔されてしまったりして不安定なものになってしまう。そのため主要なブラウザでは最大で60fps(1秒に60回)に固定されている。
今後この問題を解決するようなAPIが登場すればWebにおけるモーション取得の背景も変わってくるが、今のWeb標準規格では60fpsの中でうまくやりくりをして精度を上げつつアプリケーションを開発する必要がある。

## 今までに考え、試したアプローチ
大まかな実装の方針としては現在開発している最新のものを合わせて4つあり、実際に試した時系列順に列挙する。
### 1. 移動から特定の方向への成分を抽出し、その成分をつかうもの
センサーの値から計算した速度の値をもとに予め設定した方向の成分のみをバネのような挙動をするモデルに蓄積し、そのモデルの出力がしきい値を越えたときに音が鳴るという実装をした。設定できる方向は複数あり、その方向毎に別の音を割り当てることでメロディーを奏でることができた。
しかし、人の感覚的には直線に動かしているつもりでも実際には曲線になっていることがあり、うまく音を鳴らすためにはその点に配慮しつつ動かすと不自然な動きになってしまった。また、音を鳴らすためにスマートフォンを動かしたあと、元の位置に戻す動きも拾ってしまいユーザーの意思に反して音がなってしまうこともあった。この2点を改善するためにはそれぞれ正反対のアプローチを取る必要があり、どちらかを改善するともう一方が悪化することが多かった。

### 2. 回転の向きと強さをつかうもの
1では人の感覚と実際の動きとのズレが大きな課題だった。この2つの間でズレが生じにくいものを考えたときにデバイスの向きが挙がった。1.の実装ではデバイスそのものの動きからモデルに落としこんでいたが、今度はデバイスに生えた仮想の棒の先端の動きをモデルに落とし込むことを考えた。ちょうど、杖を振るようなイメージである。
これを実装するために、まずデバイスの向きを取得する必要があった。向きの値はまずオイラー角と呼ばれる形式で渡される。このオイラー角は数値と回転の関係性が人間の感覚的にわかりやすく、3DCG制作ソフトウェアなどでもよく使われている。その便利さの反面いくつか留意しなくてはならない点があり、その一つにジンバルロックというものがある。今回はこのジンバルロックによって値が急激に変化してしまう特異点が発生するという問題に悩まされた。この特異点があることによりユーザーの意思に反して音がなってしまうことが予想されるため、この影響を減らすためにデバイスの向きの値から誤差を減らすことに注力した。
調査の結果今回のケースに合う誤差軽減方法としてMadgwickフィルターという方法があることがわかり、この適用に取り組んだが望んだ結果にはならなかった。一番大きな原因として考えられるのは1秒あたりのサンプリング数である。Madgwickフィルターでは1秒あたりのサンプリング数が誤差軽減のための一要素になっており、Web以外の実装サンプルでは1000fps程度になっているものもある。前述のとおりJavaScriptに用意されているAPIで取得できる値のサンプリング数が60fpsであるため、これでは満足な誤差抑制ができないという判断をし、次の手を考えることにした。

### 3. デバイスの移動した軌跡をつかうもの
デバイスの移動や回転から軌跡を計算、その軌跡の特徴をつかうことを目指したものである。ここでいう特徴とは、軌跡の膨らみや速度の変化の仕方などである。誤差の影響を抑えるため、直近数フレーム分の値を蓄積するなどの対策をとった。結果的に誤差の影響自体はある程度軽減することができた。しかし、誤差の影響をより抑えるために蓄積するフレーム数を増やすと、実際の動きが音に反映されるまでに遅延発生し、人間の感覚との間にズレが出てしまった。

技術的な側面でも問題があった。
軌跡から抽出する特徴は複数の数学的操作と条件分岐によって構成されている。数学的操作には内積・外積など線形代数の基本的な計算から、三角関数や指数関数などを組み合わせた数値変換などを用いたが、管理する必要性がある係数が複数生じた。同様に、条件分岐のための複数のしきい値の管理も必要だった。
今までのアプローチでは計算したい値は数種類で比較的少なかったため、実装の設計上メインのロジックは一つのファイルにまとめて記述していた。汎用性の高い計算処理は別ファイルに分割していたが、今回も同様に特徴抽出のための殆どのロジックをすべて一つのファイルに詰め込んでいた。
そのことで、すべての係数やしきい値をそのファイルの中で管理することになってしまい、値の意味やお互いの関係性に透明性が薄れ、命名も難しくなってしまった。

### 4. 誤差に耐えられるモデルに移動・向きを落とし込み、そのモデルをつかうもの
このアプローチに移る前にまず、3.で問題になった技術的課題の解決に取り組んだ。詳細は次節の技術的成果を参照のこと。
3.では誤差の軽減のために直近数フレームの値を蓄積するという方法を試していたが、これはあくまでフレーム毎に独立した計算だった。そのため、3.で述べているような遅延の問題などとのトレードオフが発生してしまった。このトレードオフから抜け出すためにフレームの独立性をなくしたものがこのアプローチである。
このアプローチでは全フレームの値を一つの数値計算モデルに蓄積している。
今回はデバイスの現実での位置に追従する球体をイメージしたモデルを考えた。デバイスの移動や傾きからその球体を回転させ、球が特定の角度になったときに音が出るという仕組みである。
2.のアプローチでもデバイスの向きの値を使用しているが、絶対的な向きの取得を目指していた2.とは違い今回はフレーム間での相対的な向きの変化をモデルに蓄積していく形をとっている。絶対的な向きを使った場合はデバイスが現実で同じ向きであればモデルの数値も同値になるが、相対的な向きを使う場合は誤差の影響によりこれが同値にならない。このことで確かに感覚とのズレは生じるが、2.で問題になっていた特異点の問題と比べると十分無視できる範囲だと考えた。

## 技術的成果
3.のアプローチで浮上していた技術的問題を解決するため、自作のライブラリを作成した。
このライブラリは、線形代数などのベクトルの計算を使ったロジックのコンポーネント化を可能にするものである。
一つのファイルに詰め込んでいた数値計算のロジックを分割し、係数やしきい値を独立した小さな範囲で管理することが可能になった。ロジックを分割することでロジック間での値の受け渡しが必要になるが、ロジック間の関係性を有向非巡回グラフという構造で表現することでこれを解決している。
自分の経験上、グラフ構造に基づく処理は実装によって計算量が膨大になってしまい処理が重くなったりバグが発生しやすくなってしまうため、このライブラリの実装は自分にとって一つの挑戦だった。また、過去に作成したライブラリは共通の具体的な実装をまとめたものばかりだったが、抽象的な部分のみを切り取ってライブラリにする経験は初めてのことだった。
(有向非巡回グラフ構造とは、ノード同士の接続に向きがあり、接続の経路を辿ったときに同じ経路を2度以上繰り返さないグラフ構造である。)

## UIについて
